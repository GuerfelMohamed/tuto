<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Miscellaneous features</title><meta charset="utf8"/><meta content="width=device-width, initial-scale=1" name="viewport"/><link rel="stylesheet" href="/css/style.css"/><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.9.0/themes/prism.min.css"/><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.9.0/components/prism-core.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.9.0/components/prism-ocaml.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.9.0/components/prism-clike.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.9.0/components/prism-reason.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.9.0/components/prism-javascript.min.js"></script><script src="/js/client.js"></script></head><body class="tuto 3.0 misc"><div class="project-page"><div class="page-header"><p class="logo-ocsigen"><a href="/" class="ocsimore_phrasing_link"><img src="/img/ocsigen-white.svg" alt="Ocsigen"/></a>
</p><p class="logo-subproject">Doc
</p><ul class="mainmenu"><li class="mainmenu-home"><a href="/" class="ocsimore_phrasing_link">Home</a>
</li><li class="mainmenu-doc mainmenu-current"><a href="/tuto/6.2/manual/intro" class="ocsimore_phrasing_link">Doc</a>
</li><li><a href="/eliom/6.3/manual/intro" class="ocsimore_phrasing_link">Eliom</a>
</li><li><a href="/js_of_ocaml/3.1.0/manual/overview" class="ocsimore_phrasing_link">Js_of_ocaml</a>
</li><li><a href="/lwt/3.2.1/manual/manual" class="ocsimore_phrasing_link">Lwt</a>
</li><li><a href="/tyxml/4.1.0/manual/intro" class="ocsimore_phrasing_link">Tyxml</a>
</li><li><a href="/ocsigen-start/1.1.0/manual/intro" class="ocsimore_phrasing_link">Start</a>
</li></ul><div class="how-drawer"><input id="how-drawer-toggle" type="checkbox"/><label for="how-drawer-toggle" id="how-drawer-label"><span class="how-drawer-icon"></span></label><nav class="how-drawer-content"><ul class="drawermainmenu"><li class="drawermainmenu-home"><a href="/" class="ocsimore_phrasing_link">Home</a>
</li><li class="drawermainmenu-doc drawermainmenu-current"><a href="/tuto/6.2/manual/intro" class="ocsimore_phrasing_link">Doc</a>
</li><li class="drawermainmenu-project"><a href="/eliom/6.3/manual/intro" class="ocsimore_phrasing_link">Eliom</a>
</li><li class="drawermainmenu-project"><a href="/js_of_ocaml/3.1.0/manual/overview" class="ocsimore_phrasing_link">Js_of_ocaml</a>
</li><li class="drawermainmenu-project"><a href="/ocsigenserver/2.9/manual/quickstart" class="ocsimore_phrasing_link">Server</a>
</li><li class="drawermainmenu-project"><a href="/lwt/3.2.1/manual/manual" class="ocsimore_phrasing_link">Lwt</a>
</li><li class="drawermainmenu-project"><a href="/tyxml/4.1.0/manual/intro" class="ocsimore_phrasing_link">Tyxml</a>
</li><li class="drawermainmenu-project"><a href="/ocsigen-toolkit/1.1.0/manual/intro" class="ocsimore_phrasing_link">Toolkit</a>
</li><li class="drawermainmenu-project"><a href="/ocsigen-start/1.1.0/manual/intro" class="ocsimore_phrasing_link">Start</a>
</li><li class="drawermainmenu-page"><a href="/projects" class="ocsimore_phrasing_link">Other projects</a>
</li><li class="drawermainmenu-page"><a href="/papers" class="ocsimore_phrasing_link">Research papers</a>
</li><li class="drawermainmenu-page"><a href="/credits" class="ocsimore_phrasing_link">Who does Ocsigen?</a>
</li><li class="drawermainmenu-page"><a href="/blog" class="ocsimore_phrasing_link">Blog</a>
</li><li class="drawermainmenu-page"><a href="https://github.com/ocsigen" class="ocsimore_phrasing_link">Source code</a>
</li></ul><div class="how-doctree"><h1> Tutorial: Your first application</h1><h2><a href="/tuto/3.0/manual/intro" class="ocsimore_phrasing_link">Introduction</a></h2><h2><a href="/tuto/3.0/manual/application" class="ocsimore_phrasing_link">Client/server application</a></h2><h2><a href="/tuto/3.0/manual/interaction" class="ocsimore_phrasing_link">Service based Web programming</a></h2><h2><a href="/tuto/3.0/manual/misc" class="ocsimore_phrasing_link">Miscellaneous features</a></h2><h1> Examples: Learning by example</h1><h2><a href="/tuto/3.0/manual/chat" class="ocsimore_phrasing_link">Chat</a></h2><h1> Mini-tutorials: Some little examples</h1><h2><a href="/tuto/3.0/manual/tutowidgets" class="ocsimore_phrasing_link">Eliom apps basics: writing client server widgets</a></h2><h2><a href="/tuto/3.0/manual/macaque" class="ocsimore_phrasing_link">MaCaQue: SQL queries</a></h2><h2><a href="/tuto/3.0/manual/custom-conf" class="ocsimore_phrasing_link">Custom configuration</a></h2><h2><a href="/tuto/3.0/manual/ocsipersist" class="ocsimore_phrasing_link">Light database</a></h2><h2><a href="/tuto/3.0/manual/pictures" class="ocsimore_phrasing_link">Upload pictures</a></h2><h2><a href="/tuto/3.0/manual/music" class="ocsimore_phrasing_link">Playing music</a></h2><h2><a href="/tuto/3.0/manual/hash-password" class="ocsimore_phrasing_link">Protecting passwords</a></h2></div></nav></div></div><p class="reasonwarning">Warning: Reason support is experimental.
We are looking for beta-tester and contributors.
</p><button id="reason">Switch to </button><div class="twocols"><div class="leftcol"><div class="how-versions"><input id="how-versions-toggle" type="checkbox"/><label for="how-versions-toggle" class="how-versions-current">Version 3.0</label><div class="how-versions-all"><a href="/tuto/dev/manual/misc">dev</a><a href="/tuto/6.2/manual/misc">6.2</a><a href="/tuto/6.1/manual/misc">6.1</a><a href="/tuto/6.0/manual/misc">6.0</a><a href="/tuto/5.0/manual/misc">5.0</a><a href="/tuto/4.2/manual/misc">4.2</a><a href="/tuto/4.1/manual/misc">4.1</a><a href="/tuto/4.0/manual/misc">4.0</a><span class="how-versions-all-current">3.0</span><a href="/tuto/2.2/manual/misc">2.2</a><a href="/tuto/2.0/manual/misc">2.0</a></div></div><form id="search"><input name="q" id="q" placeholder="search ..."/><button>Search</button></form><div class="how-doctree"><h1> Tutorial: Your first application</h1><h2><a href="/tuto/3.0/manual/intro" class="ocsimore_phrasing_link">Introduction</a></h2><h2><a href="/tuto/3.0/manual/application" class="ocsimore_phrasing_link">Client/server application</a></h2><h2><a href="/tuto/3.0/manual/interaction" class="ocsimore_phrasing_link">Service based Web programming</a></h2><h2><a href="/tuto/3.0/manual/misc" class="ocsimore_phrasing_link">Miscellaneous features</a></h2><h1> Examples: Learning by example</h1><h2><a href="/tuto/3.0/manual/chat" class="ocsimore_phrasing_link">Chat</a></h2><h1> Mini-tutorials: Some little examples</h1><h2><a href="/tuto/3.0/manual/tutowidgets" class="ocsimore_phrasing_link">Eliom apps basics: writing client server widgets</a></h2><h2><a href="/tuto/3.0/manual/macaque" class="ocsimore_phrasing_link">MaCaQue: SQL queries</a></h2><h2><a href="/tuto/3.0/manual/custom-conf" class="ocsimore_phrasing_link">Custom configuration</a></h2><h2><a href="/tuto/3.0/manual/ocsipersist" class="ocsimore_phrasing_link">Light database</a></h2><h2><a href="/tuto/3.0/manual/pictures" class="ocsimore_phrasing_link">Upload pictures</a></h2><h2><a href="/tuto/3.0/manual/music" class="ocsimore_phrasing_link">Playing music</a></h2><h2><a href="/tuto/3.0/manual/hash-password" class="ocsimore_phrasing_link">Protecting passwords</a></h2></div></div><div class="rightcol"><h1>Miscellaneous features</h1><p><em>The code of this tutorial has been tested with Eliom 3.</em> <br/>
</p><h2>Multi-user collaborative drawing application</h2><p>We now want to take back our collaborative drawing application and
turn it to a multi user one. Each user will have his own drawing,
where everyone can draw, and the owner will have the ability to save
the drawing he wants and create an Atom feed containing all saved drawings.
</p><p>Download the <span><a href="/tuto/3.0/manual/files/tutorial.tar.gz" class="ocsforge_doclink_tuto">full code</a></span> of the examples
or browse it
<a href="/darcs/tutorial/files/tutorial/chapter3/multigraffiti" class="ocsimore_phrasing_link">online</a>.
</p><h3>Split application into multiple files and using several canvas</h3><aside class="concepts"><header><h5>Concepts</h5></header><p>Complex eliom project<br/>Unique elements</p></aside><p>In this first section, we will build a multi-canvas drawing application.
Each drawing has its own URL. Everyone can create a new drawing by going
to the corresponding URL.
</p><p>We need to refactor some parts. In particular, we need to be able to handle
separately different drawings. To do this, we will turn all global
variable, like the bus, in local ones.
</p><p>When an application grows, it start being useful to split it in
multiple files. For sake of example, we will split graffiti into 4
files.
</p><ul><li> <span class="teletype">common.ml</span> which will be part of both client and server,
containing shared types and declarations
</li><li> <span class="teletype">client.ml</span> client only part of the application
</li><li> <span class="teletype">server.ml</span> server only part of the application
</li><li> <span class="teletype">graffiti.eliom</span> the only part where we need to include both client and server code
</li></ul><h4><span class="teletype">common.ml</span></h4><p>It contains what was in <span class="teletype"> {shared{ ... }} </span>
</p><pre class=""><code class="language-ocaml translatable">type messages = (string * int * (int * int) * (int * int)) deriving (Json)

let width = 700
let height = 400</code></pre><h4><span class="teletype">client.ml</span></h4><p>It is almost the same code as what was enclosed in <span class="teletype"> {client{ ... }} </span>
with the difference that what was previously in the client value
function <span class="teletype"> init_client </span> is now in the function <span class="teletype"> launch_client_canvas</span>.
</p><pre class=""><code class="language-ocaml translatable">open Eliom_content
open Common
open Lwt

let draw ctx (color, size, (x1, y1), (x2, y2)) =
  ctx##strokeStyle &lt;- (Js.string color);
  ctx##lineWidth &lt;- float size;
  ctx##beginPath();
  ctx##moveTo(float x1, float y1);
  ctx##lineTo(float x2, float y2);
  ctx##stroke()

(* type containing all informations we need to stop interaction
   inside the page *)
type drawing_canceller =
    { drawing_thread : unit Lwt.t;
      (* the thread reading messages from the bus *)
      drawing_event_thread : unit Lwt.t;
      (* the thread handling mouse events *)
    }

let stop_drawing { drawing_thread; drawing_event_thread } =
  Lwt.cancel drawing_thread;
  (* cancelling this thread also closes the bus *)
  Lwt.cancel drawing_event_thread</code></pre><p>Notice that the client does not keep data from pages it left.
<span class="teletype">Lwt.cancel t</span> stops the thread t. In this case it also closes the
bus on which t is listening. For more informations see the
<span><a class="ocsforge_doclink_lwt" href="/lwt/3.2.1/manual/manual">Lwt programming guide </a></span> and
<span><a class="ocsforge_doclink_eliom" href="/eliom/dev/api/client/Eliom_bus">Eliom_bus</a></span>.
</p><pre class=""><code class="language-ocaml translatable">let launch_client_canvas bus image_elt canvas_elt =
  let canvas = Html5.To_dom.of_canvas canvas_elt in
  let ctx = canvas##getContext (Dom_html._2d_) in
  ctx##lineCap &lt;- Js.string &quot;round&quot;;

  let img = Html5.To_dom.of_img image_elt in
  let copy_image () = ctx##drawImage(img, 0., 0.) in
  if Js.to_bool (img##complete)
  then copy_image ()
  else img##onload &lt;- Dom_html.handler
    (fun ev -&gt; copy_image (); Js._false);

  (* Size of the brush *)
  let slider = jsnew Goog.Ui.slider(Js.null) in
  slider##setMinimum(1.);
  slider##setMaximum(80.);
  slider##setValue(10.);
  slider##setMoveToPointEnabled(Js._true);
  slider##render(Js.some Dom_html.document##body);

  (* The color palette: *)
  let pSmall =
    jsnew Goog.Ui.hsvPalette(Js.null, Js.null,
                             Js.some (Js.string &quot;goog-hsv-palette-sm&quot;))
  in
  pSmall##render(Js.some Dom_html.document##body);

  let x = ref 0 and y = ref 0 in
  let set_coord ev =
    let x0, y0 = Dom_html.elementClientPosition canvas in
    x := ev##clientX - x0; y := ev##clientY - y0 in
  let compute_line ev =
    let oldx = !x and oldy = !y in
    set_coord ev;
    let color = Js.to_string (pSmall##getColor()) in
    let size = int_of_float (Js.to_float (slider##getValue())) in
    (color, size, (oldx, oldy), (!x, !y))
  in
  let line ev =
    let v = compute_line ev in
    let _ = Eliom_bus.write bus v in
    draw ctx v;
    Lwt.return ()
  in
  let t = Lwt_stream.iter (draw ctx) (Eliom_bus.stream bus) in
  let drawing_event_thread =
    let open Lwt_js_events in
    mousedowns canvas
      (fun ev _ -&gt; set_coord ev; line ev ~&gt;&gt;= fun () -&gt;
        Lwt.pick [mousemoves Dom_html.document (fun x _ -&gt; line x);
		  mouseup Dom_html.document ~&gt;&gt;= line])
  in
  { drawing_thread = t;
    drawing_event_thread = drawing_event_thread }</code></pre><h4><span class="teletype">server.ml</span></h4><p>It contains almost all the server parts of the code.
</p><pre class=""><code class="language-ocaml translatable">open Eliom_content
open Eliom_content.Html5.D
open Common

module My_app =
  Eliom_registration.App (
    struct
      let application_name = &quot;graffiti&quot;
    end)

let rgb_from_string color = (* color is in format &quot;#rrggbb&quot; *)
  let get_color i =
    (float_of_string (&quot;0x&quot;^(String.sub color (1+2*i) 2))) /. 255.
  in
  try get_color 0, get_color 1, get_color 2 with | _ -&gt; 0.,0.,0.</code></pre><p>The main difference is that the bus is now local.
</p><pre class=""><code class="language-ocaml translatable">let launch_server_canvas () =
  let bus = Eliom_bus.create Json.t&lt;messages&gt; in

  let draw_server, image_string =
    let surface = Cairo.image_surface_create
      Cairo.FORMAT_ARGB32 ~width ~height in
    let ctx = Cairo.create surface in
    ((fun ((color : string), size, (x1, y1), (x2, y2)) -&gt;

      (* Set thickness of brush *)
      Cairo.set_line_width ctx (float size) ;
      Cairo.set_line_join ctx Cairo.LINE_JOIN_ROUND ;
      Cairo.set_line_cap ctx Cairo.LINE_CAP_ROUND ;
      let red, green, blue =  rgb_from_string color in
      Cairo.set_source_rgb ctx ~red ~green ~blue ;

      Cairo.move_to ctx (float x1) (float y1) ;
      Cairo.line_to ctx (float x2) (float y2) ;
      Cairo.close_path ctx ;

      (* Apply the ink *)
      Cairo.stroke ctx ;
     ),
     (fun () -&gt;
       let b = Buffer.create 10000 in
       (* Output a PNG in a string *)
       Cairo_png.surface_write_to_stream surface (Buffer.add_string b);
       Buffer.contents b
     ))
  in
  let _ = Lwt_stream.iter draw_server (Eliom_bus.stream bus) in
  bus,image_string

let graffiti_info = Hashtbl.create 0

let imageservice =
  Eliom_registration.String.register_service
    ~path:[&quot;image&quot;]
    ~headers:Http_headers.dyn_headers
    ~get_params:(let open Eliom_parameter in string &quot;name&quot; ** int &quot;q&quot;)
    (* we add an int parameter for the browser not to cache the image:
       at least for chrome, there is no way to force the browser to
       reload the image without leaving the application *)
    (fun (name,_) () -&gt;
      try_lwt
        let _ ,image_string = Hashtbl.find graffiti_info name in
	Lwt.return (image_string (), &quot;image/png&quot;)
      with
	| Not_found -&gt; raise_lwt Eliom_common.Eliom_404)

let get_bus (name:string) =
  (* create a new bus and image_string function only if it did not exists *)
  try
    fst (Hashtbl.find graffiti_info name)
  with
    | Not_found -&gt;
      let bus,image_string = launch_server_canvas () in
      Hashtbl.add graffiti_info name (bus,image_string);
      bus</code></pre><p>The main page now contains only a
form to choose to which drawing you want to go.
The drawing will be sent by the <span class="teletype">multigraffiti_service</span> service,
registered in <span class="teletype">graffiti.eliom</span>.
</p><pre class=""><code class="language-ocaml translatable">let main_service = Eliom_service.service ~path:[&quot;&quot;]
  ~get_params:(Eliom_parameter.unit) ()
let multigraffiti_service = Eliom_service.service ~path:[&quot;&quot;]
  ~get_params:(Eliom_parameter.suffix (Eliom_parameter.string &quot;name&quot;)) ()

let choose_drawing_form () =
  get_form ~service:multigraffiti_service
    (fun (name) -&gt;
      [fieldset
          [label ~a:[a_for name]
             [pcdata &quot;drawing name: &quot;];
           string_input ~input_type:`Text ~name ();
           br ();
           string_input ~input_type:`Submit ~value:&quot;Go&quot; ()
          ]])

let oclosure_script =
  Html5.Id.create_global_elt
    (js_script
       ~uri:(make_uri  (Eliom_service.static_dir ())
               [&quot;graffiti_oclosure.js&quot;]) ())

let make_page content =
  Lwt.return
    (html
       (head
	  (title (pcdata &quot;Graffiti&quot;))
       [ css_link
           ~uri:(make_uri (Eliom_service.static_dir ())
                  [&quot;css&quot;;&quot;common.css&quot;]) ();
         css_link
           ~uri:(make_uri (Eliom_service.static_dir ())
                  [&quot;css&quot;;&quot;hsvpalette.css&quot;]) ();
         css_link
           ~uri:(make_uri (Eliom_service.static_dir ())
                  [&quot;css&quot;;&quot;slider.css&quot;]) ();
         oclosure_script;
         css_link
           ~uri:(make_uri (Eliom_service.static_dir ())
                  [&quot;css&quot;;&quot;graffiti.css&quot;]) ();
       ])
       (body content))

let () = My_app.register ~service:main_service
  (fun () () -&gt;
    make_page [h1 [pcdata &quot;Welcome to Multigraffiti&quot;];
	       choose_drawing_form ()])</code></pre><aside class="concept"><header><h5><span class="concept_prefix">Concept: </span>Global node and scripts</h5></header><p>Sometimes we need to control when a script is loaded and reloaded on
page change. Since clicking on links in an Eliom application do not
reload the entire page, already loaded libraries stay loaded. But if
we simply add a script to each page, it will be loaded each time.
We usually don't want that.
</p><p>Using <span><a class="ocsforge_doclink_eliom" href="/eliom/6.3/api/server/Eliom_content.Html5.Id#VALcreate_global_elt">Eliom_content.​Html5.​Id.​create_global_elt</a></span> we can create an xml node
manipulated 'by reference'. If a reference to a script node is
included in a page, it will only be loaded the first time it appears
in the header. Such a node can be created that way:
</p><pre class=""><code class="language-ocaml translatable">let oclosure_script =
  Eliom_content.Html5.Id.create_global_elt
    (js_script
       ~uri:(make_uri  (Eliom_service.static_dir ())
               [&quot;graffiti_oclosure.js&quot;]) ())</code></pre></aside><h4><span class="teletype">graffiti.eliom</span></h4><p>Here is the code that mixes client and server parts.
</p><p>We first open the corresponding modules for each parts of the
application.
</p><pre class=""><code class="language-ocaml translatable">{shared{
  open Eliom_content.Html5.D
  open Common
}}
{client{
  open Client
}}
open Server</code></pre><p>And then we define a function initializing the client application by
side effects in a client value.
</p><pre class=""><code class="language-ocaml translatable">let start_drawing name image canvas =
  let bus = get_bus name in
  ignore {unit{
    let canceller = launch_client_canvas %bus %image %canvas in
    Eliom_client.onunload (fun () -&gt; stop_drawing canceller)
  }}</code></pre><p>The function registered by <span><a class="ocsforge_doclink_eliom" href="/eliom/6.3/api/client/Eliom_service#VALonunload">Eliom_service.​onunload</a></span> will be called when
the page change inside the application.
</p><p>And we finally register the service sending a drawing:
</p><pre class=""><code class="language-ocaml translatable">let counter = ref 0

let () = My_app.register ~service:multigraffiti_service
  (fun name () -&gt;
    (* Some browsers won't reload the image, so we force
       them by changing the url each time. *)
    incr counter;
    let image =
      img ~alt:name
        ~src:(make_uri
		~service:imageservice (name,!counter)) () in
    let canvas =
      canvas ~a:[ a_width width; a_height height ]
        [pcdata &quot;your browser doesn't support canvas&quot;; br (); image] in
    start_drawing name image canvas;
    make_page
      [h1 [pcdata name];
       choose_drawing_form ();
       canvas;])</code></pre><p>At this point, you can run your application on the server provided that you installed the css and images directories in the main directory of your application, build it using this <span><a href="/tuto/3.0/manual/files/tutorial/chapter3/multigraffiti/Makefile" class="ocsforge_doclink_tuto">{{{Makefile}}}</a></span> along with this <span><a href="/tuto/3.0/manual/files/tutorial/chapter3/multigraffiti/Makefile.common" class="ocsforge_doclink_tuto">{{{Makefile.common}}}</a></span> and configured it using <span><a href="/tuto/3.0/manual/files/tutorial/chapter3/multigraffiti/graffiti.conf.in" class="ocsforge_doclink_tuto">{{{graffiti.conf.in}}}</a></span> as groundwork of configuration file.
</p><h3>Mixing client/server application with traditional web interaction</h3><p>We now want to restrict the site to connected users.
</p><p>From the previous chapter, we copy the code handling users to <span class="teletype">server.ml</span>:
</p><pre class=""><code class="language-ocaml translatable">let connection_service =
  Eliom_service.post_coservice' ~post_params:
    (let open Eliom_parameter in (string &quot;name&quot; ** string &quot;password&quot;)) ()
let disconnection_service = Eliom_service.post_coservice'
  ~post_params:Eliom_parameter.unit ()
let create_account_service =
  Eliom_service.post_coservice ~fallback:main_service ~post_params:
  (let open Eliom_parameter in (string &quot;name&quot; ** string &quot;password&quot;)) ()

let username = Eliom_reference.eref ~scope:Eliom_common.default_session_scope None

let users = ref [&quot;user&quot;,&quot;password&quot;;&quot;test&quot;,&quot;test&quot;]

let check_pwd name pwd =
 try Lwt.return (List.assoc name !users = pwd) with
   | Not_found -&gt; Lwt.return false

let () = Eliom_registration.Action.register
  ~service:create_account_service
  (fun () (name, pwd) -&gt;
    users := (name, pwd)::!users;
    Lwt.return ())

let () = Eliom_registration.Action.register
  ~service:connection_service
  (fun () (name, password) -&gt;
    match_lwt check_pwd name password with
      | true -&gt; Eliom_reference.set username (Some name)
      | false -&gt; Lwt.return ())

let () =
  Eliom_registration.Action.register
    ~service:disconnection_service
    (fun () () -&gt; Eliom_state.discard ~scope:Eliom_common.default_session_scope ())

let disconnect_box () =
  post_form disconnection_service
    (fun _ -&gt; [fieldset
                 [string_input ~input_type:`Submit ~value:&quot;Log out&quot; ()]]) ()

let login_name_form service button_text =
  post_form ~service
    (fun (name1, name2) -&gt;
      [fieldset
         [label ~a:[a_for name1] [pcdata &quot;login: &quot;];
          string_input ~input_type:`Text ~name:name1 ();
          br ();
          label ~a:[a_for name2] [pcdata &quot;password: &quot;];
          string_input ~input_type:`Password ~name:name2 ();
          br ();
          string_input ~input_type:`Submit ~value:button_text ()
         ]]) ()</code></pre><p>We make a customized registration module such that disconnected users
(those for which the username reference is not set), are automaticaly
shown a connection box. That way the other pages can assume that the
username is always available.
</p><pre class=""><code class="language-ocaml translatable">let default_content () =
  make_page
    [h1 [pcdata &quot;Welcome to Multigraffiti&quot;];
     h2 [pcdata &quot;log in&quot;];
     login_name_form connection_service &quot;Connect&quot;;
     h2 [pcdata &quot;create account&quot;];
     login_name_form create_account_service &quot;Create account&quot;;]

module Connected_translate =
struct
  type page = string -&gt; My_app.page Lwt.t
  let translate page =
    match_lwt Eliom_reference.get username with
      | None -&gt; default_content ()
      | Some username -&gt; page username
end

module Connected =
  Eliom_registration.Customize ( My_app ) ( Connected_translate )</code></pre><p>We replace the previous <span class="teletype">main_service</span> registration :
</p><pre class=""><code class="language-ocaml translatable">let () = My_app.register ~service:main_service
  (fun () () -&gt;
    make_page [h1 [pcdata &quot;Welcome to Multigraffiti&quot;];
	       choose_drawing_form ()])</code></pre><p>by :
</p><pre class=""><code class="language-ocaml translatable">let () = Connected.register ~service:main_service
  (fun () () -&gt;
    Lwt.return
      (fun username -&gt;
        make_page
          [h1 [pcdata (&quot;Welcome to Multigraffiti &quot; ^ username)];
          choose_drawing_form ()]))</code></pre><p>to use that, in <span class="teletype">graffiti.eliom</span> we just replace add a call
to <span class="teletype">disconnect_box</span>
</p><pre class=""><code class="language-ocaml translatable">[h1 [pcdata name];
       disconnect_box ();
       choose_drawing_form ();
       canvas;])</code></pre><p><a href="/tuto/3.0/manual/interaction" class="ocsimore_phrasing_link">prev</a>
</p></div></div></div></body></html>
